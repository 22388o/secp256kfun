# SigmaFUN!

A framework for making sigma protocols fun!

## Use

``` toml
[dependencies]
# For just the traits and combinators
sigma_fun = {version = "0.1", no-default-features = true, features = ["alloc"]}
# To create secp256k1 non-interactive proofs and serialize them
sigma_fun = { version = "0.1", features = ["secp256k1", "serde"] }
# needed for non-interactive proofs
rand_chacha = "0.3"
sha2 = "0.9"
```

### Should use?

Highly experimental and breaking changes to the API and to the backwards compatibility of the proofs may happen at any time.

There could easily be mistakes especially in the more complicated proofs in the `ext` module!

## "Sigma" Protocols

Sigma protocols are three-round *honest verifier zero knowledge protocols* and are one of the most fundamental Zero-Knowledge proof systems.
They are extremely useful because they are easy to make non-interactive through the Fiat-Shamir transform and support various types of composition.
Sigma protocols can be used to construct signature schemes, verifiable random functions, authentication schemes, anonymous credential schemes and many more exotic things.

For a basic background on Sigma protocols see section 5 of
[Shoenmaker](https://www.win.tue.nl/~berry/CryptographicProtocols/LectureNotes.pdf)'s excellent
lecture notes.

## Composition

One of the best aspects of Sigma protocols is that if you have two Sigma protocols for proving
statements `A` and `B` you can easily compose them into a protocol for proving `A or B`. The
resulting protocol will also be a Sigma protocol! At the moment this library supports the following
combinators:

- `or(A,B)`  proves that one of the two statements is true. 
- `and(A,B)` proves both statements are true.
- `eq(A,B)`  proves two statements have the same witness (usually `A` is the same kind of proof as `B`).
- `all(n,A)` proves that `n` statements of type `A` are true.
- `eq-all(n,A)`  proves that `n` statements of type `A` all have the same witness. 

We are missing support for generically proving `t-of-m` statements are true (which is much more tricky).
Unfortunately, at the moment `n` in `all` and `eq-all` must be known at compile time.

## The `Sigma` trait

This library provides a `Sigma` trait which can be implemented for any Sigma protocol regardless of how the underlying proof is structured.
Anything implementing `Sigma` can then be composed with the combinators to create more intricate Sigma protocols.
Finally, the protocol can be made non-interactive with the resulting proofs implementing [`serde`] serialization traits.

In this library we instantiate Sigma protocols with five main algorithms:

- **`gen_announce_secret(rng) -> announce_secret`**: Generates the secret random value used in the proof from a given random number generator `rng`

- **`announce(statement, announce_secret) -> announcement`**: Given the statement to be proved and an
  `announce_secret` previously generated by `announcement_secret`, returns an `announcement`.

- **`implied_announcement(statement, challenge, response) -> announcement`**: Determines an `announcement` such that `(statement, announcement, challenge, response)` is a *valid* transcript for the sigma protocol.

- **`sample_response(rng) -> response`**: samples a response uniformly from the response space. 

- **`respond(witness, statement, announce_secret, announcement, challenge) -> response`**: Computes a valid response to the `challenge`

Each Sigma protocol also has defines its `ChallengeLength` as an associated type.

With these algorithms the interactive Sigma protocol plays out like this:

```ignore
Prover(witness, statement)                                                 Verifier(statement)
======
announce_secret = gen_announce_secret(rng)
announcement = announce(statement, announce_secret)
                                                      announcement
                                                  +------------------->
                                                       challenge         *uniformly sample ChallengeLength bytes*
                                                  <-------------------+
response = respond(witness, statement, 
                   announce_secret, announcement, 
                   challenge)

                                                       response 
                                                  +-------------------> 
                                                                                            check
                                                                        implied_announcement(statement, challenge, response) 
                                                                                              == 
                                                                                         announcement
```

### Non-interactive proofs 

The standard trick for making Sigma protocols non-interactive is to produce the `challenge` in the above diagram from a hash function.
This is called the Fiat-Shamir heuristic and is secure in the *random oracle model*.
The verifier can just check that the hash was computed correctly and the response is correct.

## Example

```rust 
use std::string::ToString;
use sigma_fun::{ typenum::U16, FiatShamir, HashTranscript, Either, Or, secp256k1::{ self, fun::{Point, Scalar, G, marker::*, g}}};
use sha2::Sha256;
use rand_chacha::ChaCha20Rng;

// Pretend to choose H securely
let H = Point::random(&mut rand::thread_rng());
// our commitment will be to 1
let c = Scalar::from(1u32);
// lets use a 16-byte (128-bit) challenge length
type L = U16;

let (C,r) = {
    // make a pedersen commitment
    let r = Scalar::random(&mut rand::thread_rng());
    let C = g!(r * G + c * H).mark::<(Normal,NonZero)>().unwrap();
    (C,r)
};

// Our strategy is to prove that we know x such that either C = x * G or C - H = x * G using 
// an OR composition between two standard knowledge of discrete logarithm proofs.
let statement = (C, g!(C - H).mark::<(Normal,NonZero)>().unwrap());
// since we are commiting to 1 we know the witness for the right hand side statement.
let witness =  Either::Right(r);

// Our prover is going to prove knowledge of one of two point to the base G (either C or C - H).
type Protocol = Or::<secp256k1::DLG<L>, secp256k1::DLG<L>>;

// Every protocol has an unambiguous name which is hashed into the transcript for protocol separation purposes.
assert_eq!(Protocol::default().to_string(), "or(DLG(secp256k1),DLG(secp256k1))");
// we want an non-interactive proof system so we apply the Fiat-Shamir transform with Sha256 doing the transform.
let proof_system  = FiatShamir::<Protocol, HashTranscript<Sha256, ChaCha20Rng>>::default();

// Make the non-interactive proof
let proof = proof_system.prove(&witness, &statement, Some(&mut rand::thread_rng()));

// The verifier gets sent (C, proof)
{
    // The verifier's proof system doesn't need the rng
    let proof_system = FiatShamir::<Protocol, HashTranscript<Sha256>>::default();
    // They recreate the statement
    let statement = (C, g!(C - H).mark::<(Normal,NonZero)>().unwrap());
    // and verify it against the proof
    assert!(proof_system.verify(&statement, &proof));
}

```

## See Also

- [ZKP](https://crates.io/crates/zkp) crate -- Helped inspire this library. `zkp` is opinionated about hash function (sha3) and group (ristretto) and only supports `eq` and `and` type composition.

[`serde`]: https://docs.rs/serde
